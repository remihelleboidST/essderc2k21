%Latex document for ESSDERC 2021 Paper 

\documentclass[11pt,a4paper,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{authblk}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{fourier}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{empheq}


\setlength{\parindent}{0pt}
\usepackage[left=1cm,right=2cm,top=2cm,bottom=2cm]{geometry}

% Title
\title{3D Simulation of PDE and Jitter in SPAD Devices.}

% AUthors and affiliation
\author[1]{RÃ©mi Helleboid}
\author[1]{Denis Rideau}
\author[1]{Jeremy Grebot}
\author[2]{Norbert Moussy}
\author[2]{Olivier Saxod}
\affil[1]{ST Microelectronics, Crolles, France}
\affil[2]{CEA LETI, Grenoble, France}

\date{}                     %% To hide the date
\setcounter{Maxaffil}{0}
\renewcommand\Affilfont{\itshape\small}
% Keywords command
\providecommand{\keywords}[1]
{
  \small	
  \textbf{\textit{Keywords---}} #1
}


\begin{document}


% Title
\maketitle

% Abstract
\begin{abstract}
In this paper we present a full 3D simulation methodology to extract Photon Detection Probability (PDP) and Jitter of Single-Photon Avalanche Diode (SPAD) Devices. The simulation results are compared with measurements on devices and show good agreement with the experiments.\\
\end{abstract}

% Keywords
\keywords{single-photon avalanche diode (SPAD), photon detection probability (PDP), jitter, avalanche breakdown probability, breakdown voltage}

% Introduction
\section{Introduction}
Single-photon avalanche diodes (SPADs) are key opto-electronics devices.


\section{Device structure and TCAD simulation}
\begin{figure}[hbtp]
\caption{SPAD simulation workflow}
\includegraphics[scale=0.21]{../pictures/TCADWorkflow.png}
\end{figure}


\section{Avalanche breakdown probability}
The avalanche breakdown probability is computed by the means of the well known McIntyre model \cite{oldham_triggering_1972}. We briefly recall the model derivation : 
Let $P_e(x)$ be the probability that an electron starting at x in the depletion layer triggers an avalanche and $P_h(x)$ the same probability for an hole starting at x.
Straightforwardly, the probability that neither an hole nor an electron starting at x trigger an avalanche is given by $(1-P_e(x))(1-P_h(x))$.
Thus, the probability that either the hole or the electron trigger an avalanche, noted $P_{pair}$ is :
\begin{align*}
P_{pair}(x) &= 1 - \left( 1-P_e(x)\right)\left(1-P_h(x)\right)  \\
			&= P_e + P_h - P_e P_h
\end{align*}

Now, the probability that an electron starting at $x+dx$ triggers an avalanche is :
The probability that the electron reaches the position $x$ and triggers an avalanche in $x$ plus the probability that it triggers an avalanche between $x$ and $x+dx$ less the probability of the intersection of the two previous events. It writes : 
\begin{align*}
P_e(x+dx) &= P_e(x) + \alpha_e(x) dx P_{pair}(x)  - P_e(x)  \alpha_e dx P_{pair}(x) \\
		  &= P_e(x) + \alpha_e(x) dx (P_e(x) + P_h(x) - P_e(x) P_h(x)) \\& \qquad - P_e(x) \alpha_e(x) dx (P_e(x) + P_h(x) - P_e(x) P_h(x)) \\
		  &=  P_e(x) + dx \, \alpha_e(x) (P_e(x) + P_h(x) - P_e(x) P_h(x)) (1 - P_e(x))
\end{align*}
Where $\alpha_e$ is the electron linear ionization rate : the probability by length that an electron create an impact ionization event.  \\
One can rearrange the terms to obtain : 
\[ \frac{P_e(x+dx)-P_e(x)}{dx} = \alpha_e(x) (P_e(x) + P_h(x) - P_e(x) P_h(x)) (1 - P_e(x)) \]
Which leads to the first ordinary differential equation : 
\[ \frac{dP_e}{dx} = (1-P_e)\alpha_e(P_e + P_h - P_e  P_h) \]

The same reasoning applies to the probability that an hole starting at $x-dx$ triggers an avalanche.
Which leads to the second ordinary differential equation : 
\[ \frac{dP_h}{dx} = -(1-P_h)\alpha_h(P_e + P_h - P_e  P_h) \]

Therefore we can draw up the McIntyre system : 

\begin{empheq}[left=\empheqlbrace]{align}
&\frac{dP_e}{dx} = (1-P_e)\alpha_e(P_e + P_h - P_e  P_h) \\
&\frac{dP_h}{dx} = -(1-P_h)\alpha_h(P_e + P_h - P_e  P_h) 
\end{empheq}
for $ 0 \leq x \leq W$. \\
Adding the couple of boundary value conditions
 : 
\begin{empheq}[left=\empheqlbrace]{align}
& P_e(x=0) = 0 \\
& P_h(x=W) = 0 
\end{empheq}
we have a full 1D coupled and non-linear boundary value problem.
Since we have to extract this value at a large number of points, we use a self-made solver, embedded in a C++ program. This solver uses finite difference method coupled with a Newton's method to care of the non-linearity of the problem \cite{ascher_numerical_1987}. The algorithm is different from those implemented in MatLab routine $\textrm{(bvp4c)}$ or SciPy function $\textrm{(solve\_bvp)}$ \cite{kierzenka_bvp_2001} but the comparison with these tools show no difference. \\
We set the following notations : 
 \[ Y(x) = \begin{pmatrix}
P_e(x) \\
P_h(x)
\end{pmatrix}
 \]

 \[ f(Y, x) = \begin{pmatrix}
(1-Y_1(x))\alpha_e(Y_1(x) + Y_2(x) - Y_1(x)  Y_2(x)) \\
-(1-Y_2(x))\alpha_h(Y_1(x) + Y_2(x) - Y_1(x)  Y_2(x)) 
\end{pmatrix}
\]

\[ g(s_1, s_2) = \begin{pmatrix}
s_1 \\
s_2
\end{pmatrix} \]

The problem hence reads : 
\begin{empheq}[left=\empheqlbrace]{align}\label{BVP_Prob}
	&Y'(x) = f(Y, x) \\
	&g(Y(0), Y(w)) = 0
\end{empheq}


\subsection{Newton scheme}
\subsubsection{Finite differences approximation}
Let $\mathcal{M}$ be the mesh on which we work. It is given by the streamlines construction. So we have : 
\[\mathcal{M}: 0 = x_1 < x_2 < x_3 < \cdots < x_N < x_{N+1} = w \]
The approximated solution on mesh $\mathcal{M}$ is $Y_{\mathcal{M}} = (y_1, y_2, \cdots, y_N, y_{N+1})$, where $y_i$ is the approximation of $Y(x_i)$.\\
For numerical approximation we again consider the mesh $\mathcal{M}$ and denote the vector of approximate solution values at mesh points by $Y_{\mathcal{M}}$. The trapezoidal scheme of finite difference methods is given by : 
\begin{align}\label{TrapezScheme}
&\frac{y_{i+1}-y_{i}}{h_{i}}=\frac{1}{2}\left(f\left(x_{i+1}, y_{i+1}\right)+f\left(x_{i}, y_{i}\right)\right) \quad 1 \leq i \leq N \\
&\quad g\left(y_{1}, y_{N+1}\right)=0
\end{align}
Thus we obtain a system of $2(N +1)$ algebraic equations for the $2(N +1)$ unknowns $Y_{\mathcal{M}}$. Unlike before, though, these equations are non-linear. The number $N$ depends on the precision we take when we construct the streamlines. We commonly take a range of $\left[1nm, 10nm\right]$, we then have $N \sim 5000$. \\
Fortunately, the Jacobian matrix of this system is rather sparse, as we shall see below.

\subsubsection{Newton method}
We consider a system of equation written in the compact form : \[ \textbf{F(s) = 0} \]
We define a function \textbf{G} : 
\[  \textbf{G}(\textbf{s}) = \textbf{s} - \left[\textbf{F}'(\textbf{s}) \right]^{-1} \textbf{F}(\textbf{s})\]
with $\textbf{F}'(\textbf{s})^{-1} $ the inverse of the Jacobian matrix of F : 
\[\textbf{F}'(\textbf{s}) = \frac{\partial\textbf{F}(\textbf{s}) }{\partial \textbf{s}}  \]

Then the newton method iterative method is given by the iteration : 
\[\textbf{s}^{k+1} =  \textbf{G}(\textbf{s}^k) \]

So the algorithm will first solve the linear system : 
\begin{equation}
\mathbf{F}^{\prime}\left(\mathbf{s}^{k}\right) \boldsymbol{\xi}=-\mathbf{F}\left(\mathbf{s}^{k}\right)
\end{equation} 
And then simply do : 
\begin{equation}
\textbf{s}^{k+1} = \textbf{s}^{k} + \boldsymbol{\xi}
\end{equation} 

\subsubsection{Construction of the linear system}

Let $\textbf{N}_{\mathcal{M}}$ be the following discrete differential operator : 
\[ \textbf{N}_{\mathcal{M}} \textbf{y}_i = \frac{y_{i+1}-y_{i}}{h_{i}}-\frac{1}{2}\left(f\left(x_{i+1}, y_{i+1}\right)+f\left(x_{i}, y_{i}\right)\right) \]

Then \[ \textbf{F}(\textbf{s}) = \begin{pmatrix}
N_{\mathcal{M}}\textbf{y}_1 \\
N_{\mathcal{M}}\textbf{y}_1 \\
\vdots \\
N_{\mathcal{M}}\textbf{y}_N \\
g(y_1, y_{N+1})
\end{pmatrix}
 \] 
We set
\[  \boldsymbol{\xi} = \begin{pmatrix}
\textbf{w}_1 \\
\textbf{w}_2 \\
\vdots \\
\textbf{w}_N \\
\textbf{w}_{N+1}
\end{pmatrix}
\]
So that the Newton method iteration becomes : 
\begin{equation}
\frac{\mathbf{w}_{i+1}-\mathbf{w}_{i}}{h_{i}}-\frac{1}{2}\left[A\left(x_{i+1}\right) \mathbf{w}_{i+1}+A\left(x_{i}\right) \mathbf{w}_{i}\right]=-\mathbf{N}_{\mathcal{M}} \mathbf{y}_{i}^{k	} \quad 1 \leq i \leq N
\end{equation}
\begin{equation}
B_{a} w_{1}+B_{b} w_{N+1}=-g\left(y_{1}^{m}, y_{N+1}^{m}\right)
\end{equation}
Where $A$ is the following matrix : 
$$
A\left(x_{j}\right):=\frac{\partial f}{\partial y}\left(x_{j},{\mathbf{y}}_{j}^{k}\right)
$$
And with $$
B_{a}=\frac{\partial g(\mathbf{y_1^k}, \mathbf{y_{N+1}^k})}{\partial \mathbf{u}}, \quad B_{b}=\frac{\partial \mathbf{g}(\mathbf{y_1^k}, \mathbf{y_{N+1}^k})}{\partial \mathbf{v}}
$$
which here turns into : 
$$
B_{a}=1, \quad B_{b}=1	
$$

\subsubsection{Final algorithm and comparison with SciPy function}
The corresponding algorithm is details at algorithm \ref{algo_newton}. The algorithm results were checked with the SciPy routine as a reference. When the number of points is greater than 500, the relative error is always bellow 1\%.
\begin{figure}[hbtp]
\caption{Comparison of the Newton's method agaisnt the SciPy routine with 512 points.}
\centering
\includegraphics[scale=0.18]{../pictures/NewtonVsScipy.png}
\end{figure}


\IncMargin{1em}
\begin{algorithm}[h]
	\SetKwData{Left}{left}
	\SetKwData{This}{this}
	\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}
	\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
	\Input{The Boundary value Problem}
	\Input{The Mesh $\mathcal{M}$}
	\Input{An initial guess of $Y_{\mathcal{M}}$}
	\Input{A maximal tolerance TOL}
	\Input{A maximal number of iterations}
	\Output{The Solution  $Y_{\mathcal{M}}$}
	\Output{The final residual error }
	\BlankLine
	$\text{RES} \leftarrow  1000$ \;
	$NbIterations \leftarrow 0$\;
	Initialize $w_{\mathcal{M}}$ as a vector of size 2N\;
	\BlankLine
	\While{$RES > TOL$ and NbIterations < MaxNbIterations}{
		\For{i=1 to 2N}{
			Construct $S_i$\;
			Construct $R_i$\;
		 	Construct $q_i =-\textbf{N}_{\mathcal{M}}y_i$\;	}
		Construct $A$\;
		Construct $\beta$\;
		\BlankLine
		Solve $A  w_{\mathcal{M}} = \hat{\beta}$\;
		\BlankLine
		{\For{i=1 to 2N}
			{$y_i \leftarrow y_i + \left( w_{\mathcal{M}}\right)_i $ }}
		\BlankLine
		$RES \leftarrow ||w_{\mathcal{M}}||$\;
		$NbIterations \leftarrow NbIterations + 1$\;
	}
	\If{$RES \leq TOL$}{
		//The method has converged \;
		\Return	Y\;
	}
	\Else{
		//The method has converged \;
		\Return Error : No Convergence
	}
	
	
\caption{Newton's Method Solver for BVP}\label{algo_newton}
\end{algorithm}
\DecMargin{1em}



\begin{figure}[h]
\caption{Field line of electric field inside the device}
\centering
\includegraphics[scale=0.4]{../pictures/SL1.png}
\end{figure}

\section{Jitter modeling}

\section{Results and comparisons with experiments}

\section{Discussion}

\newpage
\newpage
\nocite{*}
\bibliographystyle{apalike}
\bibliography{../biblio/essderc2k21}


















\end{document}